# Staging environment configuration for Azure Kubernetes Service
global:
  namespace: action-agent-stg
  environment: staging
  imageRegistry: "aagent.azurecr.io"  # Updated to correct ACR
  imageTag: "stg"

# Azure Container Registry pull secrets
# Using Azure Managed Identity with AcrPull role assignment
# No hardcoded credentials needed for staging environment
#
# Setup instructions:
# 1. Assign AcrPull role to the AKS managed identity for the ACR
# 2. Create the acr-secret manually or via external-secrets operator
# 3. Or use workload identity with ACR integration
imagePullSecrets:
  - name: acr-secret

# Azure Container Registry credentials
# Disabled for staging - using Azure Managed Identity instead
acrCredentials:
  enabled: false

# Chart naming configuration
nameOverride: ""
fullnameOverride: ""

# Use Azure Key Vault for secret management
secrets:
  enabled: true
  provider: "azure"
  azure:
    secretStoreName: "action-agent-secret-store-stg"
    tenantId: "${AZURE_TENANT_ID}"                     # Set via environment variable
    vaultUrl: "https://action-agent-kv-stg.vault.azure.net/"
    managedIdentityClientId: "${AZURE_MANAGED_IDENTITY_CLIENT_ID}"  # Set via environment variable
    refreshInterval: "15s"
    secretKeys:
      api-gateway:
        - envName: "HTTPS_PORT"
          keyVaultKey: "stg-api-gateway-https-port"
        - envName: "SSL_KEY_PATH" 
          keyVaultKey: "stg-api-gateway-ssl-key"
        - envName: "SSL_CERT_PATH"
          keyVaultKey: "stg-api-gateway-ssl-cert"
        - envName: "USER_SERVICE_URL"
          keyVaultKey: "stg-user-service-url"
        - envName: "AI_SERVICE_URL"
          keyVaultKey: "stg-ai-service-url"
        - envName: "EXTENSION_SERVICE_URL"
          keyVaultKey: "stg-extension-service-url"
      user-service:
        - envName: "MONGODB_CONNECTION_STRING"
          keyVaultKey: "stg-mongodb-connection-string"
        - envName: "JWT_SECRET"
          keyVaultKey: "stg-jwt-secret"
        - envName: "EMAIL_USERNAME"
          keyVaultKey: "stg-email-username"
        - envName: "EMAIL_PASSWORD"
          keyVaultKey: "stg-email-password"
        - envName: "API_GATEWAY_URL"
          keyVaultKey: "stg-api-gateway-url"
        - envName: "GOOGLE_APP_CLIENT_ID"
          keyVaultKey: "stg-google-client-id"
        - envName: "GOOGLE_APP_CLIENT_SECRET"
          keyVaultKey: "stg-google-client-secret"
        - envName: "GOOGLE_APP_REDIRECT_URL"
          keyVaultKey: "stg-google-redirect-url"
        - envName: "FACEBOOK_APP_CLIENT_ID"
          keyVaultKey: "stg-facebook-client-id"
        - envName: "FACEBOOK_APP_CLIENT_SECRET"
          keyVaultKey: "stg-facebook-client-secret"
        - envName: "FACEBOOK_APP_REDIRECT_URL"
          keyVaultKey: "stg-facebook-redirect-url"
        - envName: "CLIENT_URL"
          keyVaultKey: "stg-client-url"
      ai-service:
        - envName: "POSTGRES_HOST"
          keyVaultKey: "stg-postgres-host"
        - envName: "POSTGRES_PORT"
          keyVaultKey: "stg-postgres-port"
        - envName: "POSTGRES_USER"
          keyVaultKey: "stg-postgres-user"
        - envName: "POSTGRES_PASSWORD"
          keyVaultKey: "stg-postgres-password"
        - envName: "POSTGRES_DB"
          keyVaultKey: "stg-postgres-db"
        - envName: "LLM_DEFAULT_PROVIDER"
          keyVaultKey: "stg-llm-default-provider"
        - envName: "LLM_DEFAULT_MODEL"
          keyVaultKey: "stg-llm-default-model"
        - envName: "LLM_DEFAULT_API_KEY"
          keyVaultKey: "stg-llm-default-api-key"
        - envName: "TOOL_TAVILY_API_KEY"
          keyVaultKey: "stg-tool-tavily-api-key"
        - envName: "COMPOSIO_API_KEY"
          keyVaultKey: "stg-composio-api-key"
        - envName: "COMPOSIO_REDIRECT_URL"
          keyVaultKey: "stg-composio-redirect-url"
        - envName: "FRONTEND_REDIRECT_URL"
          keyVaultKey: "stg-frontend-redirect-url"
        - envName: "REDIS_URL"
          keyVaultKey: "stg-redis-url"
        - envName: "ELASTICSEARCH_URL"
          keyVaultKey: "stg-elasticsearch-url"
        - envName: "RABBITMQ_URL"
          keyVaultKey: "stg-rabbitmq-url"
      extension-service:
        - envName: "COMPOSIO_API_BASE_URL"
          keyVaultKey: "stg-composio-api-base-url"
        - envName: "COMPOSIO_API_KEY"
          keyVaultKey: "stg-composio-api-key"
        - envName: "DATABASE_URL"
          keyVaultKey: "stg-extension-db-url"

# Service configurations - use Azure Container Registry images
services:
  apiGateway:
    enabled: true
    replicaCount: 2
    image:
      repository: "api-gateway"
      tag: "stg"
      pullPolicy: Always
    imagePullSecrets:
      - name: "acr-secret"  # Azure Container Registry pull secret
    service:
      type: ClusterIP
      port: 15000
    ssl:
      enabled: true
      secretName: "api-gateway-ssl-certs"
    resources:
      requests:
        cpu: 100m
        memory: 256Mi
      limits:
        cpu: 1000m
        memory: 1Gi
    healthCheck:
      path: "/ping"
      livenessProbe:
        initialDelaySeconds: 30
        periodSeconds: 60
        timeoutSeconds: 5
        failureThreshold: 3
      readinessProbe:
        initialDelaySeconds: 5
        periodSeconds: 60
        timeoutSeconds: 5
        failureThreshold: 3
    nodeSelector:
      kubernetes.io/os: linux
    tolerations: []
    affinity:
      podAntiAffinity:
        preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchExpressions:
              - key: app.kubernetes.io/component
                operator: In
                values:
                - api-gateway
            topologyKey: kubernetes.io/hostname

  userService:
    enabled: true
    replicaCount: 2
    image:
      repository: "user-service"
      tag: "stg"
      pullPolicy: Always
    imagePullSecrets:
      - name: "acr-secret"
    service:
      type: ClusterIP
      port: 15100
    resources:
      requests:
        cpu: 100m
        memory: 256Mi
      limits:
        cpu: 1000m
        memory: 1Gi
    healthCheck:
      path: "/ping"
      livenessProbe:
        initialDelaySeconds: 30
        periodSeconds: 60
        timeoutSeconds: 5
        failureThreshold: 3
      readinessProbe:
        initialDelaySeconds: 5
        periodSeconds: 60
        timeoutSeconds: 5
        failureThreshold: 3
    nodeSelector:
      kubernetes.io/os: linux
    affinity:
      podAntiAffinity:
        preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchExpressions:
              - key: app.kubernetes.io/component
                operator: In
                values:
                - user-service
            topologyKey: kubernetes.io/hostname

  aiService:
    enabled: true
    replicaCount: 2
    image:
      repository: "ai-service"
      tag: "stg"
      pullPolicy: Always
    imagePullSecrets:
      - name: "acr-secret"
    service:
      type: ClusterIP
      port: 15200
    resources:
      requests:
        cpu: 500m
        memory: 1Gi
      limits:
        cpu: 2000m
        memory: 4Gi
    healthCheck:
      path: "/ping"
      livenessProbe:
        initialDelaySeconds: 30
        periodSeconds: 60
        timeoutSeconds: 5
        failureThreshold: 3
      readinessProbe:
        initialDelaySeconds: 5
        periodSeconds: 60
        timeoutSeconds: 5
        failureThreshold: 3
    nodeSelector:
      kubernetes.io/os: linux
    affinity:
      podAntiAffinity:
        preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchExpressions:
              - key: app.kubernetes.io/component
                operator: In
                values:
                - ai-service
            topologyKey: kubernetes.io/hostname

  extensionService:
    enabled: true
    replicaCount: 2
    image:
      repository: "extension-service"
      tag: "stg"
      pullPolicy: Always
    imagePullSecrets:
      - name: "acr-secret"
    service:
      type: ClusterIP
      port: 15300
    resources:
      requests:
        cpu: 100m
        memory: 256Mi
      limits:
        cpu: 1000m
        memory: 1Gi
    healthCheck:
      path: "/ping"
      livenessProbe:
        initialDelaySeconds: 30
        periodSeconds: 60
        timeoutSeconds: 5
        failureThreshold: 3
      readinessProbe:
        initialDelaySeconds: 5
        periodSeconds: 60
        timeoutSeconds: 5
        failureThreshold: 3
    nodeSelector:
      kubernetes.io/os: linux
    affinity:
      podAntiAffinity:
        preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchExpressions:
              - key: app.kubernetes.io/component
                operator: In
                values:
                - extension-service
            topologyKey: kubernetes.io/hostname

# External services - using managed Azure services and 3rd party
external:
  elasticsearch:
    enabled: true
    url: "${ELASTICSEARCH_URL_STG}"  # Set via environment variable - e.g., Elastic Cloud
  kibana:
    enabled: true
    url: "${KIBANA_URL_STG}"        # Set via environment variable - e.g., Elastic Cloud
  rabbitmq:
    enabled: true
    url: "${RABBITMQ_URL_STG}"      # Set via environment variable - e.g., CloudAMQP
  userDatabase:
    enabled: true
    connectionString: "${USER_DATABASE_URL_STG}"  # Set via environment variable - e.g., MongoDB Atlas
  extensionDatabase:
    enabled: true
    connectionString: "${EXTENSION_DATABASE_URL_STG}"      # Set via environment variable - e.g., MongoDB Atlas
  aiDatabase:
    enabled: true
    connectionString: "${AI_DATABASE_URL_STG}" # Set via environment variable - e.g., Azure Database for PostgreSQL
  redis:
    enabled: true
    connectionString: "${REDIS_CONNECTION_STRING_STG}"    # Set via environment variable - e.g., Azure Cache for Redis

# Disable local databases since we're using managed services
databases:
  aiDatabase:
    enabled: false
  userDatabase:
    enabled: false
  extensionDatabase:
    enabled: false
  redis:
    enabled: false

# Disable local infrastructure since we're using 3rd party/managed services
infrastructure:
  elasticsearch:
    enabled: false
  kibana:
    enabled: false
  rabbitmq:
    enabled: false

# Ingress configuration for staging
ingress:
  enabled: true
  className: "nginx"
  annotations:
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/use-regex: "true"
    cert-manager.io/cluster-issuer: "letsencrypt-staging"
  hosts:
    - host: api-stg.action-agent.com
      paths:
        - path: /
          pathType: Prefix
          backend:
            service: api-gateway
            port: 15000
  tls:
    - secretName: api-stg-action-agent-com-tls
      hosts:
        - api-stg.action-agent.com

# Autoscaling for staging
autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 10
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
      - type: Percent
        value: 50
        periodSeconds: 15

# Service Account with workload identity for Azure
serviceAccount:
  create: true
  automount: true
  annotations:
    azure.workload.identity/client-id: "${AZURE_MANAGED_IDENTITY_CLIENT_ID}"
    azure.workload.identity/tenant-id: "${AZURE_TENANT_ID}"
  name: "action-agent-workload-identity"
  labels:
    azure.workload.identity/use: "true"
