input {
  http {
    port => 5044
    codec => json_lines {  # Ensure JSON lines codec is encapsulated
      target => "event_data"  # Encapsulate fields to avoid ECS conflicts
    }
  }
}

filter {
  # Parse log timestamps and ensure they're aligned with Elasticsearch's @timestamp
  if [health] == "check" {
    drop {}
  }

  date {
    match => ["[event_data][timestamp]", "ISO8601"]
    target => "@timestamp"
  }

  # Ensure incoming logs have a timestamp field and parse it
  # if [event_data][timestamp] {
  #   date {
  #     match => ["[event_data][timestamp]", "ISO8601"]
  #     target => "@timestamp"
  #   }
  # } else {
  #   # Add a fallback to the current time if no timestamp is provided
  #   mutate {
  #     add_field => { "[@metadata][fallback_timestamp]" => "%{+YYYY-MM-dd HH:mm:ss}" }
  #   }
  #   ruby {
  #     code => 'event.set('new_field', event.get('@timestamp').to_iso8601)'
  #   }
  # }

  # Optionally remove null fields to prevent processing issues
  # mutate {
  #   remove_field => ["[event_data][null_field]"]
  # }
}

output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "system-dev-logs-%{+YYYY.MM.dd}"  # Dynamic daily indices
    ecs_compatibility => "v8"  # Ensure compatibility with ECS v8 (or adjust as needed)
  }

  stdout { codec => rubydebug }  # For debugging
}
